var documenterSearchIndex = {"docs":
[{"location":"videos/#Video-Examples","page":"Video Examples","title":"Video Examples","text":"The videos below introduce MeshArrays.jl and present two use cases :\n\nintroduction of MeshArrays.jl at JuliaCon 2018, for context.\ninteractive analysis of gridded ocean model output for ECCO.\nsimulation of plastic particles following ocean currents.","category":"section"},{"location":"videos/#JuliaCon-2018","page":"Video Examples","title":"JuliaCon 2018","text":"MeshArrays.jl was first introduced at JuliaCon in 2018. This video provides some motivation and context for the project.\n\n(Image: JuliaCon-2018 presentation)","category":"section"},{"location":"videos/#Interactive-Model-Analysis","page":"Video Examples","title":"Interactive Model Analysis","text":"In this demo of interactive visualization of ocean variables, the notebook provides various options for choosing variables and viewing them. Plots etc react to these user selections as illustrated in the video. Code is based on  MeshArrays.jl (grids, arrays), OceanStateEstimation.jl (velocity fields, etc), Pluto.jl (notebook), Makie.jl (plotting), and other open source packages.\n\n(Image: ocean state estimate analysis)\n\nAnother method for interacting with data sets is to use GLMakie.jl or WGLMakie.jl. For example, Tyler.jl can be used to explore high-resolution model output.\n\n(Image: high resolution model analysis)","category":"section"},{"location":"videos/#Particle-Tracking-and-Modeling","page":"Video Examples","title":"Particle Tracking and Modeling","text":"Here we visualize a simulation of particles moving at a fixed depth in the Ocean (300m depth). This uses Drifters.jl, and MeshArrays.jl underneath, to simulate particle trajectories. \n\n(Image: simulated particle movie (300m))\n\nMore examples like this, using Julia to run models, and related work in JuliaOcean are available in the longer video below. \n\n(Image: Modeling Marine Ecosystems)","category":"section"},{"location":"tutorials/#Tutorials","page":"Notebook Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#id_Basics","page":"Notebook Tutorials","title":"Basics","text":"The basics tutorial (code link) illustrates how the MeshArrays.jl data structures let us write generic code readily applicable to whole families of grids. \n\nIt focuses on a global workflow (smoothing) that requires communication across the entire gridded domain – a key feature provided by MeshArrays.jl.  The same workflow is repeated three times, for different grid configurations commonly used in numerical models.\n\nGrid scale noise Smoothed noise\n(Image: raw) (Image: smooth)","category":"section"},{"location":"tutorials/#id_Geography","page":"Notebook Tutorials","title":"Geography","text":"The geography tutorial (code link) deals with interpolation, projection, and vizualization of gridded fields in geographic coordinates. \n\nOcean Depth Map Great Circle Path\n(Image: map projection) (Image: great circle)","category":"section"},{"location":"tutorials/#id_Vectors","page":"Notebook Tutorials","title":"Vector Fields","text":"The vectors tutorial (code link) illustrates how MeshArrays.jl represents gridded, vector fields. This enables  analyses of various quantities, like heat, flow with oceanic currents and atmospheric winds within the climate system. \n\nHorizontal Streamfunction Vertical Streamfunction\n(Image: raw) (Image: smooth)","category":"section"},{"location":"detail/#Internals","page":"Internals","title":"Internals","text":"Functions like GridSpec(\"LLC90\") return a gcmgrid struct that contains the basic specification of a global grid. This is not the grid itself – just a few parameters, ranges, and possibly a path to grid files. A gcmgrid is embeded in each MeshArray instance for which it provides a blueprint. It specifies how an array collection forms a global mesh and allows e.g. the exchange function to dispatch to the appropriate method. \n\nVarious configurations that are commonly used in Earth System Models are readily implemented using the concrete type called MeshArray. This type is in fact an alias for more specific types that can be used interchangeably via MeshArray (initially: gcmfaces or gcmarray).\n\nWithin a MeshArray, a whole Earth System Model grid is represented as an array of elementary arrays. Each one of these represents a subdomain. For example, a gcmarray instance for one Earth map x has a column array x.f of elementary 2D arrays of various sizes. \n\nThe basics tutorial illustrates how standard operations apply to MeshArray like as they do to common Array. More specialized functions and distinctive features, such as domain decomposition or plotting maps, are demo'ed in the geography tutorial and vector tutorial.","category":"section"},{"location":"detail/#Background","page":"Internals","title":"Background","text":"The origin of MeshArrays.jl is rooted in a Matlab / Octave package called gcmfaces, which was introduced in Forget et al., 2015 (doi:10.5194/gmd-8-3071-2015). GCM is an acronym for General Circulation Model, or Global Climate Model, and faces can be equivalent to meshes, arrays, facets, or subdomains (these are the elements of x.f in a MeshArray instance x).","category":"section"},{"location":"dev/#Developer-Notebooks","page":"Developer Notebooks","title":"Developer Notebooks","text":"","category":"section"},{"location":"dev/#id_JuliaGeo","page":"Developer Notebooks","title":"JuliaGeo","text":"The Polygons notebook (code link) illustrates how grids in MeshArrays.jl can be represented as sets of Polygons (2D) or LineStrings (3D) using GeoInterface.jl.\n\nThe GeometryOps notebook (code link) has a few more tests with GeometryOps.jl.","category":"section"},{"location":"main/#Main-Features","page":"Main Features","title":"Main Features","text":"Data Structures : MeshArray, gcmgrid, varmeta \nGlobal Grids : full Earth grids used in MIT climate model\nvector fields, transports, budgets\ninterpolation, distances, collocation\nvisualization (via Makie extension)\nparticle tracking (via Drifters.jl package)","category":"section"},{"location":"main/#Summary","page":"Main Features","title":"Summary","text":"The MeshArray type is a sub-type of AbstractArray with an outer array where each element is itself a 2D inner array. By default, outer and inner arrays are of all of the standard Array type. However, this setup potentially allows different choices for the outer and inner arrays – for example DistributedArrays and AxisArrays, respectively, could be an option. MeshArrays.jl thus provides a simple but general solution to analyze or e.g. simulate climate system variables. By default the MeshArray type is an alias to the MeshArrays.gcmarray type.\n\nThe internals of a MeshArray are regulated by its gcmgrid – a struct containing just a few index ranges, array sizes, and connection rules (amongst the inner arrays). A second  lightweight struct, varmeta, contains metadata about the variable inside a MeshArray – variable name, unit, time, and grid position. A general approach like this is useful because climate models often involve advanced domain decompositions (see, e.g., Global Grids), and many variables, which can put a burden on users. \n\nEncoding the grid specification inside the MeshArray data type allows user to manipulate MeshArrays just like they would manipulate Arrays without having to invoke model grid details explicitely. In addition, the provided exchange methods readily transfer data between connected subdomains to extend them at the sides. This makes it easy to compute e.g. partial derivatives and related operators like gradients, curl, or divergences over subdomain edges as often needed for precise computation of transports, budgets, etc using climate model output (see, e.g., Tutorials).","category":"section"},{"location":"main/#Data-Structures","page":"Main Features","title":"Data Structures","text":"The elements of a MeshArray /  are arrays. These elementary arrays typically represent subdomains inter-connected at their edges. The organization and connections between subdomains is determined by a user-specified gcmgrid which is embeded inside each MeshArrays.gcmarray instance. \n\nInterpolate can be used to interpolate a MeshArray to any location (i.e. arbitrary longitude, latitude pair). Exchange methods transfer data between neighboring arrays to extend computational subdomains – this is often needed in analyses of climate or ocean model output. \n\nThe current default for MeshArray is the gcmarray type, with various examples provided in the Tutorials.\n\nOne of the examples is based on a grid known as LatLonCap where each global map is associated with 5 subdomains of different sizes. The grid has 50 depth levels. Such a MeshArray has a size of (5, 50) (see Tutorials).\n\nThe underlying, MeshArray, data structure is:\n\nstruct gcmarray{T, N} <: AbstractMeshArray{T, N}\n   grid::gcmgrid\n   meta::varmeta\n   f::Array{Array{T,2},N}\n   fSize::Array{NTuple{2, Int}}\n   fIndex::Array{Int,1}\n   version::String\nend\n\nA MeshArray generally behaves just like an Array and the broadcasting of operations has notably been customized so that it reaches elements of each elementary array (i.e. within f[i] for each index of f).\n\nIn addition, Mesharray specific functions like exchange can alter the internal structure of a MeshArray by adding rows and columns at the periphery of subdomains. ","category":"section"},{"location":"main/#Embedded-Metadata","page":"Main Features","title":"Embedded Metadata","text":"A MeshArrays.gcmarray includes a gcmgrid specification which can be constructed as outlined below.\n\nstruct gcmgrid\n  path::String\n  class::String\n  nFaces::Int\n  fSize::Array{NTuple{2, Int},1}\n  ioSize::Union{NTuple{2, Int},Array{Int64,2}}\n  ioPrec::Type\n  read::Function\n  write::Function\nend\n\nThe grid class can be set to LatLonCap, CubeSphere, PeriodicChannel, or PeriodicDomain. For example, A PeriodicChannel (periodic in the x direction) of size 360 by 160, can be defined as follows.\n\npth=MeshArrays.GRID_LL360\nclass=\"PeriodicChannel\"\nioSize=(360, 160)\nioPrec=Float32\n\nγ=gcmgrid(pth, class, 1, [ioSize], ioSize, ioPrec, read, write)\n\nImportantly, a gcmgrid does not contain any actual grid data – hence its memory footprint is minimal. Grid variables are instead read to memory only when needed e.g. as shown below. To make this easy, each gcmgrid includes a pair of read / write methods to allow for basic I/O at any time. These methods are typically specified by the user although defaults are provided. \n\nusing MeshArrays, Unitful\nγ=GridSpec(\"LatLonCap\",MeshArrays.GRID_LLC90)\nm=MeshArrays.varmeta(u\"m\",fill(0.5,2),missing,\"Depth\",\"Depth\")\nD=γ.read(γ.path*\"Depth.data\",MeshArray(γ,Float64;meta=m))\n\nThe above commands define a MeshArray called D which is the one displayed at the top of this section. A definition of the varmeta structure is reported below. The position of a D point within its grid cell is given as x ∈ [0. 1.] in each direction.\n\nstruct varmeta\n  unit::Union{Unitful.Units,Number,Missing}\n  position::Array{Float64,1}\n  time::Union{DateTime,Missing,Array{DateTime,1}}\n  name::String\n  long_name::String\nend\n\n(Image: OceanDepthMap)","category":"section"},{"location":"main/#Visualization,-Particles,-Transports","page":"Main Features","title":"Visualization, Particles, Transports","text":"A simple way to plot a MeshArray consists in using the Makie extension. \n\nBy default, for a MeshArray the heatmap command plots each elementary array separately. This is illustrated in Simple Grids and in the Tutorials. If an interpolation scheme is provided then heatmap produces a global map instead. See the geography tutorial for examples. The JuliaClimate Notebooks provide more examples\n\nThe vectors tutorial illustrates a common Earth System use case – using gridded flow fields to integrate transports, streamfunctions, budgets, etc. Particle trajectories are readily computed with Drifters.jl when velocity fields are provided as MeshArrays. \n\nThe MITgcm.jl examples shows how MeshArrays.jl can ingest any standard grid from the MIT general circulation model.\n\n(Image: OceanMOC)","category":"section"},{"location":"start/#Get-Started","page":"Get Started","title":"Get Started","text":"To create your first MeshArray, open the Julia REPL and type:\n\nusing MeshArrays\nC=MeshArray(randn(21,10))","category":"section"},{"location":"start/#Simple-Grids","page":"Get Started","title":"Simple Grids","text":"The above method let's you simply specify the grid axes as ranges : \n\nusing CairoMakie\nheatmap(C,x=-10:10,y=1:10)\n\nOr you can define default grid axes, and maybe split the global grid into subdomains :\n\nnP=10; nQ=5\n(Γ,γ)=MeshArrays.Grids_simple.UnitGrid( (nP*3,nQ*2) , (nP,nQ) ; option=\"full\")\nheatmap(Γ.XC,title=\"Coordinate 1 (XC)\")","category":"section"},{"location":"start/#Global-Grids","page":"Get Started","title":"Global Grids","text":"Three grids are available directly via this package the examples (:LL360, :CS32, and :LLC90).\n\nLat-lon Cube Sphere Lat-Lon-Cap\n(Image: Lat-Lon) (Image: Cube Sphere) (Image: Lat-Lon-Cap)\n\nIn the example below we read and display a cubed-sphere grid. The Earth surface is projected on the six faces of a cube, and here each face has 32 points (CS32). \n\nusing MeshArrays,CairoMakie\nγ=GridSpec(ID=:CS32)\nDepth=GridLoadVar(\"Depth\",γ)\nheatmap(Depth,title=\"Sea Floor Depth\")\n\nor\n\nΓ=GridLoad(γ,option=:minimal)\nheatmap(Γ.YC,title=\"grid point latitudes\")\n\nnote: Note\nFor more information on grid variable names and conventions, please refer to the MITgcm docs.","category":"section"},{"location":"start/#Install","page":"Get Started","title":"Install","text":"To install MeshArrays.jl and verify it works as expected, open the Julia REPL and type:\n\nusing Pkg\nPkg.add(\"MeshArrays\")\nPkg.test(\"MeshArrays\")","category":"section"},{"location":"#MeshArrays.jl","page":"Home","title":"MeshArrays.jl","text":"MeshArrays.jl defines an array type that can contain / organize / distribute collections of inter-connected arrays as generally done in climate models (see Global Grids). Data structures defined in MeshArrays.jl can be used to simulate and analyze key variables of the climate system such as particles and transports.\n\nnote: Note\nThe basics tutorial provides a walk through of core features. The geography tutorial deals with interpolation and mapping. The vectors tutorial demonstrates functionalities related to vector fields and transport processes. The JuliaClimate Notebooks link to a collection of use cases.","category":"section"},{"location":"API/#API-documentation","page":"API documentation","title":"API documentation","text":"","category":"section"},{"location":"API/#1.-Data-Structures","page":"API documentation","title":"1. Data Structures","text":"By default, the MeshArray type is an alias to MeshArrays.gcmarray.","category":"section"},{"location":"API/#More","page":"API documentation","title":"More","text":"","category":"section"},{"location":"API/#2.-Grids-And-I/O","page":"API documentation","title":"2. Grids And I/O","text":"Grid definitions :\n\nLoading grids :","category":"section"},{"location":"API/#Functionalities","page":"API documentation","title":"Functionalities","text":"","category":"section"},{"location":"API/#3.-Interpolation","page":"API documentation","title":"3. Interpolation","text":"","category":"section"},{"location":"API/#4.-Vector-Fields","page":"API documentation","title":"4. Vector Fields","text":"","category":"section"},{"location":"API/#5.-Integration","page":"API documentation","title":"5. Integration","text":"","category":"section"},{"location":"API/#6.-Grid-Data-Sets","page":"API documentation","title":"6. Grid Data Sets","text":"","category":"section"},{"location":"API/#7.-Polygons","page":"API documentation","title":"7. Polygons","text":"","category":"section"},{"location":"API/#8.-Other","page":"API documentation","title":"8. Other","text":"","category":"section"},{"location":"API/#MeshArrays.AbstractMeshArray","page":"API documentation","title":"MeshArrays.AbstractMeshArray","text":"AbstractMeshArray{T, N}\n\nSubtype of AbstractArray{T, N}\n\n\n\n\n\n","category":"type"},{"location":"API/#MeshArrays.gcmarray","page":"API documentation","title":"MeshArrays.gcmarray","text":"gcmarray{T, N, AT}\n\ngcmarray data structure. Available constructors:\n\ngcmarray{T,N,AT}(grid::gcmgrid,meta::varmeta,f::Array{AT,N},\n         fSize::Array{NTuple{N, Int}},fIndex::Array{Int,1},v::String)\n\ngcmarray(grid::gcmgrid,f::Array{Array{T,2},N}) where {T,N}\ngcmarray(grid::gcmgrid,f::Array{Array{T,N},1}) where {T,N}\n\ngcmarray(grid::gcmgrid,fSize::Array{NTuple{N, Int}},fIndex::Array{Int,1})\ngcmarray(<same as above>,n3::Int)\ngcmarray(<same as above>,n3::Int,n4::Int)\n\ngcmarray(grid::gcmgrid)\ngcmarray(grid::gcmgrid,::Type{T})\ngcmarray(grid::gcmgrid,::Type{T},n3::Int)\ngcmarray(grid::gcmgrid,::Type{T},n3::Int,n4::Int)\n\ngcmarray(A::Array{T,N};meta::varmeta=defaultmeta)\n\n\n\n\n\n","category":"type"},{"location":"API/#MeshArrays.gcmgrid","page":"API documentation","title":"MeshArrays.gcmgrid","text":"gcmgrid\n\ngcmgrid data structure. Available constructors:\n\ngcmgrid(path::String, class::String, nFaces::Int, \n        fSize::Array{NTuple{2, Int},1},\n        ioSize::Union{NTuple{2, Int},Array{Int64,2}},\n        ioPrec::Type, read::Function, write::Function)\n\nThe class can be set to \"LatLonCap\", \"CubeSphere\", \"PeriodicChannel\", \"PeriodicDomain\".\n\nFor example, A periodic channel (periodic in the x direction) of size 360 by 160, can be defined as follows.\n\npath=MeshArrays.Dataset(\"GRID_LL360\")\nclass=\"PeriodicChannel\"\nioSize=(360, 160)\nioPrec=Float32\n\nγ=gcmgrid(path, class, 1, [ioSize], ioSize, ioPrec, read, write)\n\nΓ=GridLoad(γ)    \n\nPlease refer to GridSpec and UnitGrid for more info related to gcmgrid options.\n\n\n\n\n\n","category":"type"},{"location":"API/#MeshArrays.varmeta","page":"API documentation","title":"MeshArrays.varmeta","text":"varmeta\n\nvarmeta data structure. By default, unit is missing (non-dimensional), position is fill(0.5,3) (cell center), time is missing, and name / long_name is unknown.\n\nAvailable constructors:\n\nvarmeta(unit::Union{Unitful.Units,Number,Missing},position::Array{Float64,1},\n        time::Union{DateTime,Missing,Array{DateTime,1}},name::String,long_name::String)\n\nAnd:\n\ndefaultmeta = varmeta(missing,fill(0.5,3),missing,\"unknown\",\"unknown\")\n\n\n\n\n\n","category":"type"},{"location":"API/#MeshArrays.gridpath","page":"API documentation","title":"MeshArrays.gridpath","text":"gridpath\n\ngridpath data structure.\n\npath=MeshArrays.Dataset(\"GRID_LLC90\")\nγ=GridSpec(\"LatLonCap\",path)\nΓ=GridLoad(γ;option=\"light\")\nlons=[-68 -63]; lats=[-54 -66]; name=\"Drake Passage\"\nTrsct=Transect(name,lons,lats,Γ)\n\n\n\n\n\n","category":"type"},{"location":"API/#MeshArrays.gridmask","page":"API documentation","title":"MeshArrays.gridmask","text":"gridmask\n\ngridmask data structure.\n\nG,M,files=Integration.example()\nM\n\n\n\n\n\n","category":"type"},{"location":"API/#MeshArrays.gcmvector","page":"API documentation","title":"MeshArrays.gcmvector","text":"gcmvector{T, N}\n\ngcmvector data structure that can be used for   subsetting and indexing into a gcmarray.\n\ngcmvector{T,N}(grid::gcmgrid,f::Array{Array{T,1},N},\n         fSize::Array{NTuple{N, Int}},fIndex::Array{Int,1})\n\n\n\n\n\n\n","category":"type"},{"location":"API/#MeshArrays.gcmfaces","page":"API documentation","title":"MeshArrays.gcmfaces","text":"gcmfaces{T, N}\n\ngcmfaces data structure. Available constructors:\n\ngcmfaces{T,N}(grid::gcmgrid,f::Array{Array{T,N},1},\n         fSize::Array{NTuple{N, Int}}, aSize::NTuple{N,Int})\n\ngcmfaces(grid::gcmgrid,v1::Array{Array{T,N},1}) where {T,N}\ngcmfaces(grid::gcmgrid,::Type{T},\n         fSize::Array{NTuple{N, Int}}, aSize::NTuple{N,Int}) where {T,N}\n\ngcmfaces(grid::gcmgrid)\ngcmfaces(grid::gcmgrid,::Type{T})\ngcmfaces(grid::gcmgrid,::Type{T},n3::Int)\n\n\n\n\n\n","category":"type"},{"location":"API/#MeshArrays.GridSpec","page":"API documentation","title":"MeshArrays.GridSpec","text":"GridSpec(category=\"default\",\n    path=tempname(); np=nothing, ID=:unknown)\n\nSelect one of the pre-defined grids \neither by category parameter (e.g. \"default\" or \"ones\")\nor by ID keyword via MeshArrays.GridSpec_default or MeshArrays.GridSpec_MITgcm)\nReturn the corresponding gcmgrid\nincluding in path either a path to grid files or a placeholder like _ones or _default.\n\nusing MeshArrays\nγ=GridSpec()\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.GridSpec_default","page":"API documentation","title":"MeshArrays.GridSpec_default","text":"GridSpec_default(xy=NamedTuple(); ID=:unknown, ioPrec=Float64, tile=[])\n\nSelect one of the pre-defined grids \nor by providing xy parameter (a NamedTuple that includes :xc, :yc, :xg, :yg)\neither by ID keyword (e.g., :OISST, :Oscar, or :IAP by default)\nReturn the corresponding gcmgrid\nincl. path=\"_default\"\n\nExample:\n\nusing MeshArrays\na = MeshArrays.GridSpec_default(ID=:OISST)\nb = MeshArrays.GridSpec_default(MeshArrays.Grids_simple.xy_OISST(),tile=(1440,1020))\nc = MeshArrays.GridSpec_default(MeshArrays.Grids_simple.xy_OISST(),tile=(720,510))\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.GridSpec_MITgcm","page":"API documentation","title":"MeshArrays.GridSpec_MITgcm","text":"GridSpec_MITgcm(category=\"PeriodicDomain\", \n        path=tempname(); np=nothing, ID=:unknown)\n\nSelect one of the pre-defined grids \nor by category parameter\neither by ID keyword\nReturn the corresponding gcmgrid\nincl. path to grid files (path).\n\nInput files for these fully supported grids get  downloaded internally via MeshArrays.Dataset if needed.\n\nselection by ID\n\n:onedegree\n:LLC90\n:LLC270\n:CS32\n:default\n\nExample:\n\nusing MeshArrays\ng = GridSpec(ID=:LLC90)\n\nby category and path\n\n\"PeriodicDomain\" (default)\n\"PeriodicChannel\"\n\"CubeSphere\"\n\"LatLonCap\"`\n\nExamples:\n\nusing MeshArrays\ng = GridSpec(\"CubeSphere\",MeshArrays.Dataset(\"GRID_CS32\"))\nisa(g,gcmgrid)\n\nWhen the np keyword argument is specified then it is used  to set the number of points in each grid subdomain.\n\nExample:\n\nusing MeshArrays\ng = GridSpec(\"LatLonCap\",np=270)\nisa(g,gcmgrid)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.Grids_simple.GridSpec_ones","page":"API documentation","title":"MeshArrays.Grids_simple.GridSpec_ones","text":"GridSpec_ones(grTp; ioPrec=Float64,nP=10,nF=1)\n\nDefine grid where all variables will be set to one via GridLoad_ones.\n\nPossible values for grTp` : \"LatLonCap\",\"CubeSphere\",\"PeriodicChannel\",\"PeriodicDomain\".\nnP : number of points at each subdomain edge.\nnF (only for \"PeriodicChannel\", \"PeriodicDomain\" grids) : number of subdomains.\n\nusing MeshArrays\nγ=MeshArrays.GridSpec_ones(\"CubeSphere\")\nΓ=MeshArrays.GridLoad_ones(γ;option=\"full\")\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.GridLoad","page":"API documentation","title":"MeshArrays.GridLoad","text":"GridLoad(γ=GridSpec(); ID=:default, option=:minimal, verbose=false)\n\nReturn a NamedTuple of grid variables read from files located in γ.path (see ?GridSpec).\nif ID is specified then call GridSpec(ID=ID) to override γ parameter.\noption : \noption=:minimal (default) to get only grid cell center positions (XC, YC). \noption=:light to get a complete set of 2D grid variables. \noption=:full  to get a complete set of 2D & 3D grid variables. \n\nFor grid variables, we follow the MITgcm naming convention. Grid variables thus typically include :\n\nXC, XG, YC, YG, AngleCS, AngleSN, Depth\nRAC, RAW, RAS, RAZ, DXC, DXG, DYC, DYG\nthree-dimensional : hFacC, hFacS, hFacW\none-dimensional : DRC, DRF, RC, RF\n\nFor additional detail please refer to the MITgcm documentation : \n\nhttps://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#spatial-discretization-of-the-dynamical-equations\n\nusing MeshArrays\nγ = GridSpec(ID=:LLC90)\nΓ = GridLoad(γ;option=\"full\")\n\nisa(Γ.XC,MeshArray)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.GridLoad_default","page":"API documentation","title":"MeshArrays.GridLoad_default","text":"GridLoad_default(γ=GridSpec())\n\nMeshArrays.GridSpec_default(ID=:IAP)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.Grids_simple.GridLoad_ones","page":"API documentation","title":"MeshArrays.Grids_simple.GridLoad_ones","text":"GridLoad_ones(γ::gcmgrid;option=\"minimal\")\n\nGenerate a unit grid, where every grid spacing and area is 1,  as specified by γ obtained from GridSpec_ones. \n\nusing MeshArrays\nγ=MeshArrays.GridSpec_ones(\"CubeSphere\",6,20);\nΓ=MeshArrays.GridLoad_ones(γ;option=\"full\")\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.GridLoadVar","page":"API documentation","title":"MeshArrays.GridLoadVar","text":"GridLoadVar(nam::String,γ::gcmgrid)\n\nReturn a grid variable read from files located in γ.path (see ?GridSpec, ?GridLoad).\n\nBased on the MITgcm naming convention, grid variables are:\n\nXC, XG, YC, YG, AngleCS, AngleSN, hFacC, hFacS, hFacW, Depth.\nRAC, RAW, RAS, RAZ, DXC, DXG, DYC, DYG.\nDRC, DRF, RC, RF (one-dimensional)\n\nMITgcm documentation : \n\nhttps://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#spatial-discretization-of-the-dynamical-equations\n\nusing MeshArrays\n\nγ = GridSpec(\"CubeSphere\",MeshArrays.Dataset(\"GRID_CS32\"))\nXC = GridLoadVar(\"XC\",γ)\n\nisa(XC,MeshArray)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.Tiles","page":"API documentation","title":"MeshArrays.Tiles","text":"Tiles(γ::gcmgrid,ni::Int,nj::Int)\n\nDefine sudomain tiles of size ni,nj. Each tile is defined by a Dict where tile,face,i,j correspond to tile ID, face ID, index ranges.\n\nusing MeshArrays\nγ=GridSpec(\"LatLonCap\",MeshArrays.Dataset(\"GRID_LLC90\"))\nτ=Tiles(γ,30,30)\n\nisa(τ[1],NamedTuple)\n\n\n\n\n\nTiles(τ::Array{Dict},x::AbstractMeshArray)\n\nReturn an Array of tiles which cover x according to tile partition τ.\n\nusing MeshArrays\nγ=GridSpec(\"LatLonCap\",MeshArrays.Dataset(\"GRID_LLC90\"))\nd=γ.read(γ.path*\"Depth.data\",MeshArray(γ,γ.ioPrec))\nτ=Tiles(γ,30,30)\ntd=Tiles(τ,d)\n\nD=similar(d)\nTiles!(τ,td,D)\n\nisa(td[1],Array)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.Tiles!","page":"API documentation","title":"MeshArrays.Tiles!","text":"Tiles!(τ::Array,tx::Array,x::AbstractMeshArray)\n\nMap tiles in tx according to tile partition τ into x.\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.exchange","page":"API documentation","title":"MeshArrays.exchange","text":"exchange(fld::AbstractMeshArray)\n\nExchange / transfer data between neighboring arrays. Other methods are\n\nexchange(fld::AbstractMeshArray,N::Integer)\nexchange(u::AbstractMeshArray,v::AbstractMeshArray)\nexchange(u::AbstractMeshArray,v::AbstractMeshArray,N::Integer)\n\n\n\n\n\n","category":"function"},{"location":"API/#Base.read","page":"API documentation","title":"Base.read","text":"read(fil::String,x::AbstractMeshArray)\n\nRead array from file and return as a MeshArray. \n\nThe second argument (MeshArray or gcmgrid) provides the grid specifications (x.grid.ioSize). ```\n\n\n\n\n\nread(xx::Array,γ::gcmgrid)\n\nReformat Array data into a MeshArray shaped after γ.\n\n\n\n\n\nread(xx::Array,x::AbstractMeshArray)\n\nReformat Array data into a MeshArray similar to x. \n\n\n\n\n\n","category":"function"},{"location":"API/#Base.read!","page":"API documentation","title":"Base.read!","text":"read!(xx::Array,x::AbstractMeshArray)\n\nReformat array into MeshArray and write into x.\n\n\n\n\n\n","category":"function"},{"location":"API/#Base.write","page":"API documentation","title":"Base.write","text":"write(fil::String,x::AbstractMeshArray)\n\nWrite MeshArray to binary file. Other methods:\n\nwrite(xx::Array,x::AbstractMeshArray) #to Array\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.interpolation_setup","page":"API documentation","title":"MeshArrays.interpolation_setup","text":"interpolation_setup(fil::String)\n\nRead e.g. interp_coeffs_halfdeg.jld2\n\nfil=joinpath(tempdir(),\"interp_coeffs_halfdeg.jld2\")\nλ=MeshArrays.interpolation_setup(fil)\n\n\n\n\n\ninterpolation_setup(;Γ,lon,lat,filename)\n\nDownload or recompute interpolation coefficients.\n\nλ=interpolation_setup() to download \"interpcoeffshalfdeg.jld2\" \nλ=interpolation_setup(Γ=Γ) to recompute interpolation to lon,lat\nλ=interpolation_setup(Γ=Γ,lon=lon,lat=lat,filename=filename) to    recompute interpolation to lon,lat and save to location and file filename,   defaulting to tempname()*\"_interp_coeffs.jld2\".\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.Interpolate","page":"API documentation","title":"MeshArrays.Interpolate","text":"Interpolate(z_in::AbstractMeshArray,f,i,j,w)\n\nusing MeshArrays\npath=MeshArrays.Dataset(\"GRID_LLC90\")\nγ=GridSpec(\"LatLonCap\",path)\nΓ=GridLoad(γ; option=\"full\")\n\nlon=[i for i=-179.5:1.0:179.5, j=-89.5:1.0:89.5]\nlat=[j for i=-179.5:1.0:179.5, j=-89.5:1.0:89.5]\n(f,i,j,w,j_f,j_x,j_y)=InterpolationFactors(Γ,vec(lon),vec(lat))\nDD=Interpolate(Γ.Depth,f,i,j,w)\n\nusing CairoMakie\nheatmap(vec(lon[:,1]),vec(lat[1,:]),DD,colorrange=(0.,6000.))\n\n\n\n\n\nInterpolate(z_in::AbstractMeshArray,f,i,j,w)\n\nusing MeshArrays\npath=MeshArrays.Dataset(\"GRID_LLC90\")\nγ=GridSpec(\"LatLonCap\",path)\nΓ=GridLoad(γ; option=\"full\")\n\nlon=[i for i=-179.5:1.0:179.5, j=-89.5:1.0:89.5]\nlat=[j for i=-179.5:1.0:179.5, j=-89.5:1.0:89.5]\n(f,i,j,w,j_f,j_x,j_y)=InterpolationFactors(Γ,vec(lon),vec(lat))\nL=(lon=lon, lat=lat, f=f, i=i, j=j, w=w)\n\nusing CairoMakie\nheatmap(Interpolate(Γ.Depth,L)...,colorrange=(0.,6000.))\n\nor \n\nheatmap(Γ.Depth,interpolation=L,colorrange=(0.,6000.))\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.InterpolationFactors","page":"API documentation","title":"MeshArrays.InterpolationFactors","text":"InterpolationFactors(Γ,lon::Array{T,1},lat::Array{T,1})\n\nCompute interpolation coefficients etc from grid Γ to lon,lat\n\nusing MeshArrays\npath=MeshArrays.Dataset(\"GRID_CS32\")\nγ=GridSpec(\"CubeSphere\",path)\nΓ=GridLoad(γ; option=\"full\")\nlon=collect(45.:0.1:46.); lat=collect(60.:0.1:61.)\n(f,i,j,w,j_f,j_x,j_y)=InterpolationFactors(Γ,lon,lat)\nYC=Interpolate(Γ.YC,f,i,j,w)\nextrema(i)==(9,10)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.StereographicProjection","page":"API documentation","title":"MeshArrays.StereographicProjection","text":"StereographicProjection(XC0,YC0,XC,YC)\n\nApply stereographic projection that puts XC0,YC0 at 0.0,0.0 to target point(s) XC,YC\n\nlon=collect(45.:0.1:46.); lat=collect(60.:0.1:61.)\nx,y=StereographicProjection(45.,60.,lon,lat)\n\n\n\n\n\n","category":"function"},{"location":"API/#NearestNeighbors.knn","page":"API documentation","title":"NearestNeighbors.knn","text":"knn(xgrid,ygrid::AbstractMeshArray,x,y::Array{T,1},k::Int)\n\nFind k nearest neighbors to each point in x,y on xgrid,ygrid\n\nlon=collect(0.1:0.5:2.1); lat=collect(0.1:0.5:2.1);\n(f,i,j,c)=knn(Γ.XC,Γ.YC,lon,lat)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.curl","page":"API documentation","title":"MeshArrays.curl","text":"curl(u::AbstractMeshArray,v::AbstractMeshArray,Γ::NamedTuple)\n\nCompute curl of a velocity field.\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.convergence","page":"API documentation","title":"MeshArrays.convergence","text":"convergence(uFLD::AbstractMeshArray,vFLD::AbstractMeshArray)\n\nCompute convergence of a vector field\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.gradient","page":"API documentation","title":"MeshArrays.gradient","text":"gradient(inFLD::AbstractMeshArray,Γ::NamedTuple)\n\nCompute spatial derivatives. Other methods:\n\ngradient(inFLD::AbstractMeshArray,Γ::NamedTuple,doDIV::Bool)\ngradient(inFLD::AbstractMeshArray,iDXC::AbstractMeshArray,iDYC::AbstractMeshArray)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.ScalarPotential","page":"API documentation","title":"MeshArrays.ScalarPotential","text":"ScalarPotential(TrspCon)\n\nScalar potential inversion.\n\nTrspPot=ScalarPotential(TrspCon)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.VectorPotential","page":"API documentation","title":"MeshArrays.VectorPotential","text":"VectorPotential(TrspX,TrspY,Γ,method::Int=1)\n\nVector potential inversion.\n\nTrspPot=ScalarPotential(TrspCon)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.ThroughFlow","page":"API documentation","title":"MeshArrays.ThroughFlow","text":"ThroughFlow(VectorField,IntegralPath,Γ::NamedTuple)\n\nCompute transport through an integration path\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.UVtoTransport","page":"API documentation","title":"MeshArrays.UVtoTransport","text":"UVtoTransport(U,V,G::NamedTuple)\n\nConvert e.g. velocity (m/s) to transport (m^3/s) by multiplying by DRF and DXG,DYG.\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.UVtoUEVN","page":"API documentation","title":"MeshArrays.UVtoUEVN","text":"UVtoUEVN(u,v,G::NamedTuple)\n\nInterpolate to grid cell centers (uC,vC)\nConvert to Eastward/Northward components (uE,vN)\n\nNote: land masking u,v with NaNs preemptively can be adequate.\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.Integration.loops","page":"API documentation","title":"MeshArrays.Integration.loops","text":"loops(mask::gridmask; files=String[], var=:THETA, rd=read)\n\nbegin\n  @everywhere using MeshArrays, MITgcm\n  @everywhere rd(F,var,tim,tmp)=read(read_mdsio(F,var),tmp)\n  @everywhere G,M,files=Integration.example()\n    #,regions=(30,10),depths=Integration.DEPTHS)\nend;\n\nH=Integration.loops(M,files=files,rd=rd)\n# Hbis=Integration.streamlined_loop(M,files=files,rd=rd)\n\nand to save results:\n\nusing JLD2; output_path=\"test.jld2\"\njldsave(output_path; depths=M.depths, integral=H, volume=vol, name=M.names)\n\nwhere vol is calculated as follows:\n\n#option=:loops\nallones=1.0 .+0*G.hFacC\nM.tmp2d.=M.v_int[1](allones)\nvol=[b(M.tmp2d) for b in M.h_sum]\n\nor \n\n#option=:streamlined_loop\nallones=1.0 .+0*G.hFacC\nvol=[b(allones) for b in M.h_sum]\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.Dataset","page":"API documentation","title":"MeshArrays.Dataset","text":"Dataset(d::String; do_read=true, verbose=false)\n\nget folder name for dataset d. \ndownload dataset if needed.\nread content if do_read\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.mydatadep","page":"API documentation","title":"MeshArrays.mydatadep","text":"mydatadep(nam=\"countries_shp1\")\n\nDownload data dependency with predefined name; currently :\n\n\"countries_shp1\"\n\"countries_geojson1\"\n\"basemap_jpg1\"\n\"interp_halfdeg\"\n\"oceans_geojson1\"\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.NamedPolygon","page":"API documentation","title":"MeshArrays.NamedPolygon","text":"struct NamedPolygon     geometry::Vector{Tuple{Float32, Float32}}     name::String     points::Vector{} end\n\n\n\n\n\n","category":"type"},{"location":"API/#MeshArrays.polyarray","page":"API documentation","title":"MeshArrays.polyarray","text":"struct polyarray    name::String    f::Array{NamedPolygon} end\n\nusing MeshArrays, GeoJSON, DataDeps\npol=MeshArrays.Dataset(\"oceans_geojson1\")\n\nwrite(pol,tempname()*\".json\")\n\nusing CairoMakie\nlines(pol)\n\n\n\n\n\n","category":"type"},{"location":"API/#MeshArrays.to_Polygon","page":"API documentation","title":"MeshArrays.to_Polygon","text":"to_Polygon(pa::polyarray)\n\nConvert polyarray into a GI.Polygon array.\n\npol_P,nams=MeshArrays.to_Polygon(pol)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.to_polyarray","page":"API documentation","title":"MeshArrays.to_polyarray","text":" to_polyarray(pol)\n\nConvert polygon data into a polyarray.\n\nfil=\"countries.geojson\"\nMeshArrays.to_polyarray(GeoJSON.read(fil))\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.within_pol","page":"API documentation","title":"MeshArrays.within_pol","text":"within_pol(pol; ID=1)\n\nGenerate a name,rule pair to test if location      lon,lat is within polygon pol[ID].geometry.\n\nusing MeshArrays, DataDeps, GeoJSON, GeometryOps\nfil=MeshArrays.Dataset(\"oceans_geojson1\",do_read=false)\npol=MeshArrays.read_json(fil,format=:GeoJSON)\n\nname,rule=MeshArrays.within_pol(pol; ID=11)\nrule(-30,40)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.read_json","page":"API documentation","title":"MeshArrays.read_json","text":"read_json(fil; format=:polyarray)\n\nCall GeoJSON.read and return polyarray (default)\n\nformat :polyarray(default): returnpolyarray`\nformat :coord : convert to GI.coordinates.\nformat :GeoJSON : return FeatureCollection (vector of name,geom pairs)\n\nimport MeshArrays, DataDeps, GeoJSON\npol=MeshArrays.Dataset(\"oceans_geojson1\")\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.read_shp","page":"API documentation","title":"MeshArrays.read_shp","text":"read_shp(fil; format=:polyarray)\n\nCall Shapefile.Table and Shapefile.shapes and return polyarray (default).\n\nformat :polyarray (default) : return polyarray\nformat :Shapefile : return vector of name,geometry` named tuples.\nformat :coord : convert to GI.coordinates.\n\nusing MeshArrays, DataDeps, Shapefile\nfil=MeshArrays.Dataset(\"countries_shp1\")\n\nusing CairoMakie\nlines(pol)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.LatitudeCircles","page":"API documentation","title":"MeshArrays.LatitudeCircles","text":"LatitudeCircles(LatValues,Γ::NamedTuple; format=:gridpath, range=(0.0,360.0))\n\nCompute integration paths that follow latitude circles, within the specified longitude range.\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.Transect","page":"API documentation","title":"MeshArrays.Transect","text":"Transect(name,lons,lats,Γ; segment=:short, format=:gridpath)\n\nCompute integration paths that follow a great circle between two geolocations give by lons, lats.\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.demo.ocean_basins","page":"API documentation","title":"MeshArrays.demo.ocean_basins","text":"ocean_basins()\n\nMask of ocean basins on ECCO grid (LLC90).\n\nbasins=demo.ocean_basins()\nAtlExt=extended_basin(basins,:Atl)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.demo.extended_basin","page":"API documentation","title":"MeshArrays.demo.extended_basin","text":"extended_basin(basins,ID=:Atl)\n\nConsolidate basins mask to include marginal seas. \n\nnote : has only be tested on the ECCO grid (LLC90). \n\nbasins=demo.ocean_basins()\nAtlExt=extended_basin(basins,:Atl)\n\n\n\n\n\n","category":"function"},{"location":"API/#MeshArrays.isosurface","page":"API documentation","title":"MeshArrays.isosurface","text":"isosurface(θ,T,Γ)\n\nDepth of isosurface θ=T\n\n\n\n\n\n","category":"function"}]
}
