<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MeshArrays</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MeshArrays</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../main/">Design</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#API-Guide"><span>API Guide</span></a></li></ul></li><li><a class="tocitem" href="../detail/">Detail</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/master/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="API-Guide"><a class="docs-heading-anchor" href="#API-Guide">API Guide</a><a id="API-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#API-Guide" title="Permalink"></a></h2><ul><li><a href="#MeshArrays.AbstractMeshArray"><code>MeshArrays.AbstractMeshArray</code></a></li><li><a href="#MeshArrays.gcmarray"><code>MeshArrays.gcmarray</code></a></li><li><a href="#MeshArrays.gcmfaces"><code>MeshArrays.gcmfaces</code></a></li><li><a href="#MeshArrays.gcmgrid"><code>MeshArrays.gcmgrid</code></a></li><li><a href="#MeshArrays.gcmsubset"><code>MeshArrays.gcmsubset</code></a></li><li><a href="#MeshArrays.gcmvector"><code>MeshArrays.gcmvector</code></a></li><li><a href="#MeshArrays.varmeta"><code>MeshArrays.varmeta</code></a></li><li><a href="#Base.findall-Union{Tuple{MeshArrays.gcmarray{Bool,N,AT} where AT}, Tuple{N}} where N"><code>Base.findall</code></a></li><li><a href="#Base.read-Tuple{String,MeshArrays.gcmarray}"><code>Base.read</code></a></li><li><a href="#Base.write-Tuple{String,MeshArrays.gcmarray}"><code>Base.write</code></a></li><li><a href="#MeshArrays.GridAddWS!-Tuple{Dict}"><code>MeshArrays.GridAddWS!</code></a></li><li><a href="#MeshArrays.GridLoad-Tuple{gcmgrid}"><code>MeshArrays.GridLoad</code></a></li><li><a href="#MeshArrays.GridOfOnes-Tuple{Any,Any,Any}"><code>MeshArrays.GridOfOnes</code></a></li><li><a href="#MeshArrays.GridSpec"><code>MeshArrays.GridSpec</code></a></li><li><a href="#MeshArrays.Interpolate-Tuple{MeshArrays.gcmarray,Any,Any,Any,Any}"><code>MeshArrays.Interpolate</code></a></li><li><a href="#MeshArrays.InterpolationFactors-Union{Tuple{T}, Tuple{Any,Array{T,1},Array{T,1}}} where T"><code>MeshArrays.InterpolationFactors</code></a></li><li><a href="#MeshArrays.LatitudeCircles-Tuple{Any,Dict}"><code>MeshArrays.LatitudeCircles</code></a></li><li><a href="#MeshArrays.MapWetPoints-Tuple{Any}"><code>MeshArrays.MapWetPoints</code></a></li><li><a href="#MeshArrays.MaskWetPoints-Tuple{Any}"><code>MeshArrays.MaskWetPoints</code></a></li><li><a href="#MeshArrays.MatrixForPoisson-NTuple{7,Any}"><code>MeshArrays.MatrixForPoisson</code></a></li><li><a href="#MeshArrays.ParaCoeffs"><code>MeshArrays.ParaCoeffs</code></a></li><li><a href="#MeshArrays.PolygonAngle"><code>MeshArrays.PolygonAngle</code></a></li><li><a href="#MeshArrays.QuadArrays-Union{Tuple{T}, Tuple{Array{T,2},Array{T,2}}} where T"><code>MeshArrays.QuadArrays</code></a></li><li><a href="#MeshArrays.QuadCoeffs"><code>MeshArrays.QuadCoeffs</code></a></li><li><a href="#MeshArrays.ScalarPotential-Tuple{Any}"><code>MeshArrays.ScalarPotential</code></a></li><li><a href="#MeshArrays.SeedWetPoints-Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,MeshArrays.gcmarray,Vararg{Any,N} where N}"><code>MeshArrays.SeedWetPoints</code></a></li><li><a href="#MeshArrays.StereographicProjection-NTuple{4,Any}"><code>MeshArrays.StereographicProjection</code></a></li><li><a href="#MeshArrays.ThroughFlow-Tuple{Any,Any,Dict}"><code>MeshArrays.ThroughFlow</code></a></li><li><a href="#MeshArrays.Tiles-Tuple{gcmgrid,Int64,Int64}"><code>MeshArrays.Tiles</code></a></li><li><a href="#MeshArrays.Tiles-Tuple{Array{Dict,N} where N,MeshArrays.gcmarray}"><code>MeshArrays.Tiles</code></a></li><li><a href="#MeshArrays.VectorPotential"><code>MeshArrays.VectorPotential</code></a></li><li><a href="#MeshArrays.convergence-Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray}"><code>MeshArrays.convergence</code></a></li><li><a href="#MeshArrays.exchange-Tuple{MeshArrays.gcmarray}"><code>MeshArrays.exchange</code></a></li><li><a href="#MeshArrays.fijind-Tuple{MeshArrays.gcmfaces,Int64}"><code>MeshArrays.fijind</code></a></li><li><a href="#MeshArrays.getindexetc-Union{Tuple{N}, Tuple{T}, Tuple{MeshArrays.gcmarray{T,N,Array{T,2}},Vararg{Union{Colon, Int64, AbstractUnitRange, Array{Int64,N} where N},N}}} where N where T"><code>MeshArrays.getindexetc</code></a></li><li><a href="#MeshArrays.gradient-Tuple{MeshArrays.gcmarray,Dict}"><code>MeshArrays.gradient</code></a></li><li><a href="#MeshArrays.mask-Tuple{MeshArrays.gcmarray,Number}"><code>MeshArrays.mask</code></a></li><li><a href="#MeshArrays.nFacesEtc-Tuple{MeshArrays.gcmarray}"><code>MeshArrays.nFacesEtc</code></a></li><li><a href="#MeshArrays.simple_periodic_domain"><code>MeshArrays.simple_periodic_domain</code></a></li><li><a href="#MeshArrays.smooth-Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,MeshArrays.gcmarray,Dict}"><code>MeshArrays.smooth</code></a></li><li><a href="#NearestNeighbors.knn-Union{Tuple{T}, Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,Array{T,1},Array{T,1}}, Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,Array{T,1},Array{T,1},Any}} where T"><code>NearestNeighbors.knn</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.AbstractMeshArray" href="#MeshArrays.AbstractMeshArray"><code>MeshArrays.AbstractMeshArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractMeshArray{T, N}</code></pre><p>Subtype of AbstractArray{T, N}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Types.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.gcmarray" href="#MeshArrays.gcmarray"><code>MeshArrays.gcmarray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">gcmarray{T, N, AT}</code></pre><p>gcmarray data structure. Available constructors:</p><pre><code class="language-none">gcmarray{T,N,AT}(grid::gcmgrid,meta::varmeta,f::Array{AT,N},
         fSize::Array{NTuple{N, Int}},fIndex::Array{Int,1},v::String)

gcmarray(grid::gcmgrid,f::Array{Array{T,2},N}) where {T,N}
gcmarray(grid::gcmgrid,f::Array{Array{T,N},1}) where {T,N}

gcmarray(grid::gcmgrid,fSize::Array{NTuple{N, Int}},fIndex::Array{Int,1})
gcmarray(&lt;same as above&gt;,n3::Int)
gcmarray(&lt;same as above&gt;,n3::Int,n4::Int)

gcmarray(grid::gcmgrid)
gcmarray(grid::gcmgrid,::Type{T})
gcmarray(grid::gcmgrid,::Type{T},n3::Int)
gcmarray(grid::gcmgrid,::Type{T},n3::Int,n4::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Type_gcmarray.jl#L2-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.gcmfaces" href="#MeshArrays.gcmfaces"><code>MeshArrays.gcmfaces</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">gcmfaces{T, N}</code></pre><p>gcmfaces data structure. Available constructors:</p><pre><code class="language-none">gcmfaces{T,N}(grid::gcmgrid,f::Array{Array{T,N},1},
         fSize::Array{NTuple{N, Int}}, aSize::NTuple{N,Int})

gcmfaces(grid::gcmgrid,v1::Array{Array{T,N},1}) where {T,N}
gcmfaces(grid::gcmgrid,::Type{T},
         fSize::Array{NTuple{N, Int}}, aSize::NTuple{N,Int}) where {T,N}

gcmfaces(grid::gcmgrid)
gcmfaces(grid::gcmgrid,::Type{T})
gcmfaces(grid::gcmgrid,::Type{T},n3::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Type_gcmfaces.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.gcmgrid" href="#MeshArrays.gcmgrid"><code>MeshArrays.gcmgrid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">gcmgrid</code></pre><p>gcmgrid data structure. Available constructors:</p><pre><code class="language-none">gcmgrid(path::String, class::String,
        nFaces::Int, fSize::Array{NTuple{2, Int},1},
        ioSize::Array{Int64,2}, ioPrec::Type,
        read::Function, write::Function)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Types.jl#L11-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.gcmsubset" href="#MeshArrays.gcmsubset"><code>MeshArrays.gcmsubset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">gcmsubset{T, N}</code></pre><p>gcmsubset data structure for subsets of gcmfaces. Available constructors:</p><pre><code class="language-none">gcmsubset{T,N}(grid::gcmgrid,f::Array{Array{T,N},1},
               fSize::Array{NTuple{N, Int}},aSize::NTuple{N, Int},
               i::Array{Array{T,N},1},iSize::Array{NTuple{N, Int}})
gcmsubset(grid::gcmgrid,::Type{T},fSize::Array{NTuple{N, Int}},
          aSize::NTuple{N,Int},dims::NTuple{N,Int}) where {T,N}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Type_gcmfaces.jl#L30-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.gcmvector" href="#MeshArrays.gcmvector"><code>MeshArrays.gcmvector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">gcmvector{T, N}</code></pre><p>gcmvector data structure that can be used for   subsetting and indexing into a gcmarray.</p><pre><code class="language-none">gcmvector{T,N}(grid::gcmgrid,f::Array{Array{T,1},N},
         fSize::Array{NTuple{N, Int}},fIndex::Array{Int,1})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Type_gcmvector.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.varmeta" href="#MeshArrays.varmeta"><code>MeshArrays.varmeta</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">varmeta</code></pre><p>varmeta data structure. By default, <code>unit</code> is <code>1.0</code> (non-dimensional), <code>position</code> is <code>fill(0.5,3)</code> (cell center), and <code>name</code> / <code>long_name</code> is unknown.</p><p>Available constructors:</p><pre><code class="language-none">varmeta(unit::Union{Unitful.AbstractQuantity,Number},position::Array{Float64,1},
        name::String,long_name::String)</code></pre><p>And:</p><p><code>defaultmeta = varmeta(1.0,fill(0.5,3),&quot;unknown&quot;,&quot;unknown&quot;)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Types.jl#L35-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findall-Union{Tuple{MeshArrays.gcmarray{Bool,N,AT} where AT}, Tuple{N}} where N" href="#Base.findall-Union{Tuple{MeshArrays.gcmarray{Bool,N,AT} where AT}, Tuple{N}} where N"><code>Base.findall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findall(A::gcmarray{Bool})</code></pre><p>Return a gcmvector of the true indices in A. This allows:</p><pre><code class="language-none">findall(A.&lt;0) #gcmvector of CartesianIndex{2}
A[findall(A.&lt;0)] #gcmvector of eltype(A)
view(A,findall(A.&lt;0)) #CatView of eltype(A)

A[findall(A.&lt;0)]=B[findall(A.&lt;0)]
A[findall(A.&lt;0)].=view(B,findall(A.&lt;0))
A[findall(A.&lt;0)].=NaN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Type_gcmvector.jl#L97-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{String,MeshArrays.gcmarray}" href="#Base.read-Tuple{String,MeshArrays.gcmarray}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">read(fil::String,x::MeshArray)</code></pre><p>Read binary file to MeshArray. Other methods:</p><pre><code class="language-none">read(xx::Array,x::MeshArray) #from Array</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/ReadWrite.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Tuple{String,MeshArrays.gcmarray}" href="#Base.write-Tuple{String,MeshArrays.gcmarray}"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write(fil::String,x::MeshArray)</code></pre><p>Write MeshArray to binary file. Other methods:</p><pre><code class="language-none">write(xx::Array,x::MeshArray) #to Array</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/ReadWrite.jl#L59-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.GridAddWS!-Tuple{Dict}" href="#MeshArrays.GridAddWS!-Tuple{Dict}"><code>MeshArrays.GridAddWS!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GridAddWS!(Γ::Dict)</code></pre><p>Compute XW, YW, XS, and YS (vector field locations) from XC, YC (tracer field locations) and add them to Γ.</p><pre><code class="language-none">Γ=GridLoad(GridSpec(&quot;LatLonCap&quot;,&quot;GRID_LLC90/&quot;))
GridAddWS!(Γ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Grids.jl#L267-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.GridLoad-Tuple{gcmgrid}" href="#MeshArrays.GridLoad-Tuple{gcmgrid}"><code>MeshArrays.GridLoad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GridLoad(γ::gcmgrid)</code></pre><p>Return a <code>Dict</code> of grid variables read from files located in <code>γ.path</code> (see <code>?GridSpec</code>).</p><p>Based on the MITgcm naming convention, grid variables are:</p><ul><li>XC, XG, YC, YG, AngleCS, AngleSN, hFacC, hFacS, hFacW, Depth.</li><li>RAC, RAW, RAS, RAZ, DXC, DXG, DYC, DYG.</li><li>DRC, DRF, RC, RF (one-dimensional)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Grids.jl#L94-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.GridOfOnes-Tuple{Any,Any,Any}" href="#MeshArrays.GridOfOnes-Tuple{Any,Any,Any}"><code>MeshArrays.GridOfOnes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GridOfOnes(grTp,nF,nP)</code></pre><p>Define all-ones grid variables instead of using <code>GridSpec</code> &amp; <code>GridLoad</code>. E.g.</p><pre><code class="language-none">γ,Γ=GridOfOnes(&quot;CubeSphere&quot;,6,20);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Grids.jl#L162-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.GridSpec" href="#MeshArrays.GridSpec"><code>MeshArrays.GridSpec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GridSpec(GridName,GridParentDir=&quot;./&quot;)</code></pre><p>Return a <code>gmcgrid</code> specification that provides grid files <code>path</code>, <code>class</code>, <code>nFaces</code>, <code>ioSize</code>, <code>facesSize</code>, <code>ioPrec</code>, &amp; a <code>read</code> function (not yet) using hard-coded values for <code>&quot;PeriodicDomain&quot;</code>, <code>&quot;PeriodicChannel&quot;</code>, <code>&quot;CubeSphere&quot;</code>, and `&quot;LatLonCap&quot; for now.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Grids.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.Interpolate-Tuple{MeshArrays.gcmarray,Any,Any,Any,Any}" href="#MeshArrays.Interpolate-Tuple{MeshArrays.gcmarray,Any,Any,Any,Any}"><code>MeshArrays.Interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Interpolate(z_in::MeshArray,f,i,j,w)</code></pre><pre><code class="language-none">lon=[i for i=-179.5:1.0:179.5, j=-89.5:1.0:89.5]
lat=[j for i=-179.5:1.0:179.5, j=-89.5:1.0:89.5]

Γ=GridLoad(GridSpec(&quot;LatLonCap&quot;,&quot;GRID_LLC90/&quot;))
(f,i,j,w,j_f,j_x,j_y)=InterpolationFactors(Γ,vec(lon),vec(lat))
DD=Interpolate(Γ[&quot;Depth&quot;],f,i,j,w)

using Plots
contourf(vec(lon[:,1]),vec(lat[1,:]),DD,clims=(0.,6000.))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Interpolation.jl#L54-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.InterpolationFactors-Union{Tuple{T}, Tuple{Any,Array{T,1},Array{T,1}}} where T" href="#MeshArrays.InterpolationFactors-Union{Tuple{T}, Tuple{Any,Array{T,1},Array{T,1}}} where T"><code>MeshArrays.InterpolationFactors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">InterpolationFactors(Γ,lon::Array{T,1},lat::Array{T,1})</code></pre><p>Compute interpolation coefficients etc from grid <code>Γ</code> to <code>lon,lat</code></p><pre><code class="language-none">lon=collect(45.:0.1:46.); lat=collect(60.:0.1:61.)
(f,i,j,w,j_f,j_x,j_y)=InterpolationFactors(Γ,lon,lat)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Interpolation.jl#L81-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.LatitudeCircles-Tuple{Any,Dict}" href="#MeshArrays.LatitudeCircles-Tuple{Any,Dict}"><code>MeshArrays.LatitudeCircles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LatitudeCircles(LatValues,Γ::Dict)</code></pre><p>Compute integration paths that follow latitude circles</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Operations.jl#L274-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.MapWetPoints-Tuple{Any}" href="#MeshArrays.MapWetPoints-Tuple{Any}"><code>MeshArrays.MapWetPoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MapWetPoints(mskWet)</code></pre><p>Mapping from global array to global ocean vector.</p><pre><code class="language-none">(Kvec,Lvec,Kmap,Lmap)=MapWetPoints(mskWet)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Solvers.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.MaskWetPoints-Tuple{Any}" href="#MeshArrays.MaskWetPoints-Tuple{Any}"><code>MeshArrays.MaskWetPoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MaskWetPoints(TrspCon)</code></pre><p>Mask land points with NaN.</p><pre><code class="language-none">(TrspCon, mskWet, mskDry)=MaskWetPoints(TrspCon)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Solvers.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.MatrixForPoisson-NTuple{7,Any}" href="#MeshArrays.MatrixForPoisson-NTuple{7,Any}"><code>MeshArrays.MatrixForPoisson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MatrixForPoisson(TrspCon,mskWet,mskDry,Kvec,Lvec,Kmap,Lmap)</code></pre><p>Assemble sparse matrix using mskWet, Kvec, Lvec directly and Kmap, Lmap via SeedWetPoints</p><pre><code class="language-none">A=MatrixForPoisson(TrspCon,mskWet,mskDry,Kvec,Lvec,Kmap,Lmap)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Solvers.jl#L89-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.ParaCoeffs" href="#MeshArrays.ParaCoeffs"><code>MeshArrays.ParaCoeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ParaCoeffs(px,py,ox=[],oy=[])</code></pre><p>Compute bilinear interpolation coefficients for <code>ox,oy</code> within <code>px,py</code> by remapping these parallelograms to the <code>unit square</code>.</p><ul><li><code>px,py</code> are <code>Mx4</code> matrices where each line specifies one quadrilateral.</li><li><code>ox,oy</code> are <code>MxP</code> position matrices</li><li><code>pw</code> (output) are the <code>MxPx4</code> bilinear interpolation weights</li></ul><pre><code class="language-none">x=1.0; y=1.0 #Try send the corners to unit square corners?
println(vec(ParaCoeffs([0., 2., 3., 1.]&#39;,[0., 0., 1., 1.]&#39;,x,y)))
println(vec(QuadCoeffs([0., 2.01, 3., 1.]&#39;,[0., 0., 1., 1.]&#39;,x,y)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Interpolation.jl#L399-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.PolygonAngle" href="#MeshArrays.PolygonAngle"><code>MeshArrays.PolygonAngle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">PolygonAngle(px,py,x=[],y=[])</code></pre><p>Compute sum of interior angles for polygons or points-to-polygons (when <code>px,py,x,y</code> is provided as input). <code>px,py</code> are <code>MxN</code> matrices where each line specifies one polygon. (optional) <code>x,y</code> are position vectors.</p><pre><code class="language-none">px=[0. 0. 1. 1.]; py=[0. 1. 1. 0.];
x=collect(-1.0:0.25:2.0); y=x;
PolygonAngle(px,py,x,y)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Interpolation.jl#L223-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.QuadArrays-Union{Tuple{T}, Tuple{Array{T,2},Array{T,2}}} where T" href="#MeshArrays.QuadArrays-Union{Tuple{T}, Tuple{Array{T,2},Array{T,2}}} where T"><code>MeshArrays.QuadArrays</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QuadArrays(x_grid,y_grid)</code></pre><p>Transform x<em>grid,y</em>grid (size ni+2,nj+2) into x<em>quad,y</em>quad,i<em>quad,j</em>quad quadrilaterals (size ni+1*nj+1,4) where i<em>quad,j</em>quad are point indices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Interpolation.jl#L273-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.QuadCoeffs" href="#MeshArrays.QuadCoeffs"><code>MeshArrays.QuadCoeffs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">QuadCoeffs(px,py,ox=[],oy=[])</code></pre><p>Compute bilinear interpolation coefficients for <code>ox,oy</code> within <code>px,py</code> by remapping these quadrilaterals to the <code>unit square</code>.</p><ul><li><code>px,py</code> are <code>Mx4</code> matrices where each line specifies one quadrilateral.</li><li><code>ox,oy</code> are <code>MxP</code> position matrices</li><li><code>ow</code> (output) are the <code>MxPx4</code> bilinear interpolation weights</li></ul><pre><code class="language-none">QuadCoeffs([-1., 8., 13., -4.]&#39;,[-1., 3., 11., 8.]&#39;,0.,6.)
QuadCoeffs([0., 2., 3., 1.]&#39;,[0., 0., 1., 1.]&#39;,0.1,0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Interpolation.jl#L307-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.ScalarPotential-Tuple{Any}" href="#MeshArrays.ScalarPotential-Tuple{Any}"><code>MeshArrays.ScalarPotential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ScalarPotential(TrspCon)</code></pre><p>Scalar potential inversion.</p><pre><code class="language-none">TrspPot=ScalarPotential(TrspCon)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Solvers.jl#L129-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.SeedWetPoints-Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,MeshArrays.gcmarray,Vararg{Any,N} where N}" href="#MeshArrays.SeedWetPoints-Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,MeshArrays.gcmarray,Vararg{Any,N} where N}"><code>MeshArrays.SeedWetPoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SeedWetPoints(tmp::MeshArray,Kmap::MeshArray,Lmap::MeshArray,I...)</code></pre><p>Seed a subset of grid points.</p><pre><code class="language-none">(FLDones,FLDkkFROM)=SeedWetPoints(tmp::MeshArray,Kmap::MeshArray,Lmap::MeshArray,I...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Solvers.jl#L50-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.StereographicProjection-NTuple{4,Any}" href="#MeshArrays.StereographicProjection-NTuple{4,Any}"><code>MeshArrays.StereographicProjection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">StereographicProjection(XC0,YC0,XC,YC)</code></pre><p>Apply stereographic projection that puts <code>XC0,YC0</code> at <code>0.0,0.0</code> to target point(s) <code>XC,YC</code></p><pre><code class="language-none">lon=collect(45.:0.1:46.); lat=collect(60.:0.1:61.)
x,y=StereographicProjection(45.,60.,lon,lat)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Interpolation.jl#L174-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.ThroughFlow-Tuple{Any,Any,Dict}" href="#MeshArrays.ThroughFlow-Tuple{Any,Any,Dict}"><code>MeshArrays.ThroughFlow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ThroughFlow(VectorField,IntegralPath,Γ::Dict)</code></pre><p>Compute transport through an integration path</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Operations.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.Tiles-Tuple{Array{Dict,N} where N,MeshArrays.gcmarray}" href="#MeshArrays.Tiles-Tuple{Array{Dict,N} where N,MeshArrays.gcmarray}"><code>MeshArrays.Tiles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Tiles(τ::Array{Dict},x::MeshArray)</code></pre><p>Return an <code>Array</code> of tiles which cover <code>x</code> according to tile partition <code>τ</code>.</p><pre><code class="language-none">γ=GridSpec(&quot;LatLonCap&quot;,&quot;GRID_LLC90/&quot;)
d=γ.read(γ.path*&quot;Depth.data&quot;,MeshArray(γ,γ.ioPrec))
τ=Tiles(γ,30,30)
td=Tiles(τ,d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Grids.jl#L240-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.Tiles-Tuple{gcmgrid,Int64,Int64}" href="#MeshArrays.Tiles-Tuple{gcmgrid,Int64,Int64}"><code>MeshArrays.Tiles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Tiles(γ::gcmgrid,ni::Int,nj::Int)</code></pre><p>Define sudomain <code>tiles</code> of size <code>ni,nj</code>. Each tile is defined by a <code>Dict</code> where <code>tile,face,i,j</code> correspond to tile ID, face ID, index ranges.</p><pre><code class="language-none">γ=GridSpec(&quot;LatLonCap&quot;,&quot;GRID_LLC90/&quot;)
τ=Tiles(γ,30,30)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Grids.jl#L210-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.VectorPotential" href="#MeshArrays.VectorPotential"><code>MeshArrays.VectorPotential</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">VectorPotential(TrspX,TrspY,Γ,method::Int=1)</code></pre><p>Vector potential inversion.</p><pre><code class="language-none">TrspPot=ScalarPotential(TrspCon)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Solvers.jl#L155-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.convergence-Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray}" href="#MeshArrays.convergence-Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray}"><code>MeshArrays.convergence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convergence(uFLD::MeshArray,vFLD::MeshArray)</code></pre><p>Compute convergence of a vector field</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Operations.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.exchange-Tuple{MeshArrays.gcmarray}" href="#MeshArrays.exchange-Tuple{MeshArrays.gcmarray}"><code>MeshArrays.exchange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exchange(fld::MeshArray)</code></pre><p>Exchange / transfer data between neighboring arrays. Other methods are</p><pre><code class="language-none">exchange(fld::MeshArray,N::Integer)
exchange(u::MeshArray,v::MeshArray)
exchange(u::MeshArray,v::MeshArray,N::Integer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Exchanges.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.fijind-Tuple{MeshArrays.gcmfaces,Int64}" href="#MeshArrays.fijind-Tuple{MeshArrays.gcmfaces,Int64}"><code>MeshArrays.fijind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fijind(A::gcmfaces,ij::Int)</code></pre><p>Compute face and local indices (f,j,k) from global index (ij).</p><p>(needed in other types?)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Type_gcmfaces.jl#L141-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.getindexetc-Union{Tuple{N}, Tuple{T}, Tuple{MeshArrays.gcmarray{T,N,Array{T,2}},Vararg{Union{Colon, Int64, AbstractUnitRange, Array{Int64,N} where N},N}}} where N where T" href="#MeshArrays.getindexetc-Union{Tuple{N}, Tuple{T}, Tuple{MeshArrays.gcmarray{T,N,Array{T,2}},Vararg{Union{Colon, Int64, AbstractUnitRange, Array{Int64,N} where N},N}}} where N where T"><code>MeshArrays.getindexetc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindexetc(A::gcmarray, I::Vararg{_}) where {T,N}</code></pre><p>Same as getindex but also returns the face size and index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Type_gcmarray.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.gradient-Tuple{MeshArrays.gcmarray,Dict}" href="#MeshArrays.gradient-Tuple{MeshArrays.gcmarray,Dict}"><code>MeshArrays.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradient(inFLD::MeshArray,Γ::Dict)</code></pre><p>Compute spatial derivatives. Other methods:</p><pre><code class="language-none">gradient(inFLD::MeshArray,Γ::Dict,doDIV::Bool)
gradient(inFLD::MeshArray,iDXC::MeshArray,iDYC::MeshArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Operations.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.mask-Tuple{MeshArrays.gcmarray,Number}" href="#MeshArrays.mask-Tuple{MeshArrays.gcmarray,Number}"><code>MeshArrays.mask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mask(fld::MeshArray, val::Number)</code></pre><p>Replace non finite values with val. Other methods:</p><pre><code class="language-none">mask(fld::MeshArray)
mask(fld::MeshArray, val::Number, noval::Number)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Operations.jl#L66-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.nFacesEtc-Tuple{MeshArrays.gcmarray}" href="#MeshArrays.nFacesEtc-Tuple{MeshArrays.gcmarray}"><code>MeshArrays.nFacesEtc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nFacesEtc(a::gcmarray)</code></pre><p>Return nFaces, n3 (1 in 2D case; &gt;1 otherwise)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Type_gcmarray.jl#L279-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.simple_periodic_domain" href="#MeshArrays.simple_periodic_domain"><code>MeshArrays.simple_periodic_domain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simple_periodic_domain(np::Integer,nq=missing)</code></pre><p>Set up a simple periodic domain of size np x nq</p><pre><code class="language-none">np=16 #domain size is np x np
Γ=simple_periodic_domain(np)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Grids.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MeshArrays.smooth-Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,MeshArrays.gcmarray,Dict}" href="#MeshArrays.smooth-Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,MeshArrays.gcmarray,Dict}"><code>MeshArrays.smooth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">smooth(FLD::MeshArray,DXCsm::MeshArray,DYCsm::MeshArray,Γ::Dict)</code></pre><p>Smooth out scales below DXCsm / DYCsm via diffusion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Operations.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NearestNeighbors.knn-Union{Tuple{T}, Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,Array{T,1},Array{T,1}}, Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,Array{T,1},Array{T,1},Any}} where T" href="#NearestNeighbors.knn-Union{Tuple{T}, Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,Array{T,1},Array{T,1}}, Tuple{MeshArrays.gcmarray,MeshArrays.gcmarray,Array{T,1},Array{T,1},Any}} where T"><code>NearestNeighbors.knn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">knn(xgrid,ygrid::MeshArray,x,y::Array{T,1},k::Int)</code></pre><p>Find k nearest neighbors to each point in x,y on xgrid,ygrid</p><pre><code class="language-none">lon=collect(0.1:0.5:2.1); lat=collect(0.1:0.5:2.1);
(f,i,j,c)=knn(Γ[&quot;XC&quot;],Γ[&quot;YC&quot;],lon,lat)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/MeshArrays.jl/blob/fe0055d7b38aed000b51202bce6a18c7fc3f317d/src/Interpolation.jl#L5-L14">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../main/">« Design</a><a class="docs-footer-nextpage" href="../detail/">Detail »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 27 September 2020 18:04">Sunday 27 September 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
